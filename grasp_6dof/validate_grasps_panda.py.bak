# -*- coding: utf-8 -*-
import pybullet as p
import pybullet_data
import numpy as np
import json
import time
import math
import argparse
import os
import pathlib
import random
from datetime import datetime
import csv

# ---------------------------- Utils ----------------------------
def set_global_seed(seed: int | None):
    if seed is None:
        return
    random.seed(seed)
    np.random.seed(seed)

def save_env_snapshot(out_dir="grasp_6dof/out"):
    os.makedirs(out_dir, exist_ok=True)
    snap = {
        "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "pybullet_build": p.getAPIVersion(),
    }
    path = os.path.join(out_dir, f"env_{datetime.now().strftime('%Y%m%d-%H%M%S')}.json")
    with open(path, "w") as f:
        json.dump(snap, f, indent=2, ensure_ascii=False)
    print(f"[INFO] Environment snapshot saved → {path}")

def get_table_top_z(table_id: int) -> float:
    top_z = -1e9
    for ji in range(-1, p.getNumJoints(table_id)):  # -1: base
        aabb = p.getAABB(table_id, ji)
        if aabb:
            top_z = max(top_z, aabb[1][2])
    return top_z

# ------------------------- Grasp Routine -----------------------


def grasp_with_panda(
    obj_id,
    grasp_pose,
    panda_id,
    end_effector_index=8,
    finger_ids=None,
    table_top_z=0.0,
    init_base_z=None,
    open_width_m=0.04, 
    descent_step=0.002,
    descend_clear=0.020,
    vel_close=0.25,
    pos_close=900,
    squeeze=0.35,
    step_fn=None,
    ik_iters=400,
    ik_attempts=5,
    joint_force=900.0,
):
    ### EARLY_HELPERS ###
    def _step(n):
        steps = int(n)
        if step_fn is None:
            for _ in range(steps):
                p.stepSimulation()
                time.sleep(1/480.0)
        else:
            step_fn(steps)
    
    def move_to(pos, orn=None, steps=240):
        # 注意：默认使用当前作用域的 quat_target（后面会定义），调用时应已定义
        if orn is None:
            orn = quat_target
        target = list(pos)
        joints = p.calculateInverseKinematics(
            panda_id,
            endEffectorLinkIndex=end_effector_index,
            targetPosition=target,
            targetOrientation=orn,
            solver=p.IK_DLS,
            maxNumIterations=int(IK_ITERS),
            residualThreshold=1e-4,
        )
        for j in range(7):
            p.setJointMotorControl2(panda_id, j, p.POSITION_CONTROL, joints[j], force=JOINT_FORCE)
        _step(steps)
    
    # ---- derived timing/force constants (safe & idempotent) ----
    VEL_CLOSE_TIME = float(vel_close)
    POS_CLOSE_FORCE = float(pos_close)
    SQUEEZE_EXTRA_TIME = float(squeeze)
    # ---- step function wrapper (use _step everywhere) ----
    if step_fn is None:
        def _step(n):
            for _ in range(int(n)):
                p.stepSimulation()
                time.sleep(1/480.0)
    else:
        _step = step_fn

    """
    稳定 + 高速：渐降 -> 速度找物 -> 位置夹紧 -> 轻抬二次挤压 -> 抬升判定
    使用 IK 做 7DoF 手臂控制。
    """


    # ---- 抓取局部护栏：强制提升摩擦 & 收紧开口上限 ----
    try:
        # open_width 硬上限（避免 80mm 太松导致滚滑）
        if open_width_m is not None and open_width_m > 0.075:
            open_width_m = 0.075

        # 物体/手指摩擦（含旋转摩擦）硬设置，避免外层复位覆盖
        p.changeDynamics(obj_id, -1,
                         lateralFriction=3.0, rollingFriction=0.08,
                         spinningFriction=0.15, restitution=0.0)
        if finger_ids is None:
            finger_ids = [9, 10]
        
    # ---------- 合爪：速度找物 -> 位置夹紧到 0.002 ----------
    except Exception:
        pass
    for fid in finger_ids:
        p.setJointMotorControl2(panda_id, fid, p.VELOCITY_CONTROL, targetVelocity=-0.2, force=40)
    _step(int(float(vel_close)*480))
    for fid in finger_ids:
        p.setJointMotorControl2(panda_id, fid, p.POSITION_CONTROL, targetPosition=0.002, force=POS_CLOSE_FORCE)
    _step(int(0.20 * 480))

    # 轻抬 1cm 促进入槽，再二次挤压到 0.0
    ee = p.getLinkState(panda_id, end_effector_index, computeForwardKinematics=True)
    ee_pos = list(ee[0])
    move_to([ee_pos[0], ee_pos[1], ee_pos[2] + 0.010], orn=quat_target, steps=140)
    for fid in finger_ids:
        p.setJointMotorControl2(panda_id, fid, p.POSITION_CONTROL, targetPosition=0.0, force=POS_CLOSE_FORCE)
    _step(int(0.20 * 480))
    
    j9 = p.getJointState(panda_id, finger_ids[0])[0]
    j10 = p.getJointState(panda_id, finger_ids[1])[0]
    print(f"[DEBUG] fingers after close: j9={j9:.3f}, j10={j10:.3f}")
    # 诊断输出：合爪后指尖张开程度
    j9 = p.getJointState(panda_id, finger_ids[0])[0]
    j10 = p.getJointState(panda_id, finger_ids[1])[0]
    print(f"[DEBUG] fingers after close: j9={j9:.3f}, j10={j10:.3f}")

    if not contact:



        cps = p.getContactPoints(bodyA=panda_id, bodyB=obj_id)
        finger_or_palm = set(finger_ids) | {8}  # 8 一般是hand/palm link
        contact = any(c[3] in finger_or_palm for c in cps)


    # 没接触就直接失败，避免盲抬横扫
    if not contact:
        for fid in finger_ids:
            p.setJointMotorControl2(
                panda_id, fid, p.POSITION_CONTROL,
                targetPosition=0.04, force=200
            )
        _step(int(0.15 * 480))
        return False
        
    # ---------- 顶靠 + 轻微 yaw 摆动（帮助指尖越过圆角） ----------
    if contact:
        down_z = max(min_target_z + 0.001, z - 0.0005)  # 轻微再下 0.5mm
        # 朝物体中心顶靠 2mm
        move_to([target_pos[0] + nudx, target_pos[1] + nudy, down_z], orn=quat_target, steps=100)

        # 在顶靠位做 ±1° yaw 摆动（很小，不刮桌）
        def yaw_wiggle(deg, steps=80):
            q = p.getQuaternionFromEuler([math.pi, 0.0, yaw + math.radians(deg)])
            move_to([target_pos[0] + nudx, target_pos[1] + nudy, down_z], orn=q, steps=steps)

        yaw_wiggle(+1.0); yaw_wiggle(-1.0)
        
        
    if (contact and not lifted and 0.0 <= dz_lift < 0.02):
        # 顶靠 2mm 并 ±1.5° yaw 摆动
        move_to([target_pos[0] + nudx, target_pos[1] + nudy, ee_pos[2]], orn=quat_target, steps=90)
        for deg in (+1.5, -1.5):
            q = p.getQuaternionFromEuler([math.pi - math.radians(2.5), 0.0, yaw + math.radians(deg)])
            move_to([target_pos[0] + nudx, target_pos[1] + nudy, ee_pos[2]], orn=q, steps=70)

        # 再重夹再抬
        for fid in finger_ids:
            p.setJointMotorControl2(panda_id, fid, p.POSITION_CONTROL,
                                    targetPosition=0.0, force=POS_CLOSE_FORCE * 1.20)
    
        _step(int((SQUEEZE_EXTRA_TIME + 0.3) * 480))
        ee = p.getLinkState(panda_id, end_effector_index, computeForwardKinematics=True)
        ee_pos = np.array(ee[0])
        move_to([ee_pos[0], ee_pos[1], ee_pos[2] + 0.10], orn=quat_target, steps=220)
    print(f"[DEBUG] min_target_z={min_target_z:.3f}, descend_step={DESCENT_STEP:.4f}, squeeze={SQUEEZE_EXTRA_TIME:.2f}s, pos_close={POS_CLOSE_FORCE:.0f}N")
    
        
    # ---------- 轻抬 + 二次挤压 ----------
    ee = p.getLinkState(panda_id, end_effector_index, computeForwardKinematics=True)
    ee_pos = np.array(ee[0])
    move_to([ee_pos[0], ee_pos[1], ee_pos[2] + 0.005], orn=quat_target, steps=160)
    for fid in finger_ids:
        p.setJointMotorControl2(panda_id, fid, p.POSITION_CONTROL, targetPosition=0.0, force=POS_CLOSE_FORCE)
    _step(int(SQUEEZE_EXTRA_TIME * 480))

    # ---------- 抬升并判定 ----------
    ee = p.getLinkState(panda_id, end_effector_index, computeForwardKinematics=True)
    ee_pos = np.array(ee[0])
    
    # ---------- 抬升并判定 ----------
    # 若刚才 Δz 很小，优先使用微倾抬升；否则常规直抬
    if contact:
        # 先尝试微倾抬升 0.25m
        try:
            tilt_lift(deg=3.0, dz=LIFT_UP, steps=360)
        except Exception:
            pass
        except Exception:
            ee = p.getLinkState(panda_id, end_effector_index, computeForwardKinematics=True)
            ee_pos = list(ee[0])
            move_to([ee_pos[0], ee_pos[1], ee_pos[2] + LIFT_UP], orn=quat_target, steps=360)
    else:
        ee = p.getLinkState(panda_id, end_effector_index, computeForwardKinematics=True)
        ee_pos = list(ee[0])
        move_to([ee_pos[0], ee_pos[1], ee_pos[2] + LIFT_UP], orn=quat_target, steps=360)
    

    now_z = p.getBasePositionAndOrientation(obj_id)[0][2]
    base_z = (init_base_z if init_base_z is not None else obj_pos0[2])
    dz_lift = now_z - base_z

    # 安全护栏：极端数值（穿桌/炸飞）直接判失败并跳过重试
    if (dz_lift < -0.05) or (abs(dz_lift) > 0.5):
        print(f"[WARN] abnormal Δz={dz_lift:.3f}, skip retry (treat as fail).")
        lifted = False
    else:
        lifted = (dz_lift > LIFT_SUCCESS_DZ)

    print(f"[DEBUG] contact={contact}, Δz={dz_lift:.3f}, success={lifted}")

    # 若“接触但抬不动”，加压重试一次（更强、更久、抬升更小）
    if (contact and not lifted and 0.0 <= dz_lift < 0.02):
        for fid in finger_ids:
            p.setJointMotorControl2(panda_id, fid, p.POSITION_CONTROL,
                                    targetPosition=0.0, force=POS_CLOSE_FORCE * 1.15)
        _step(int((SQUEEZE_EXTRA_TIME + 0.4) * 480))

        ee = p.getLinkState(panda_id, end_effector_index, computeForwardKinematics=True)
        ee_pos = np.array(ee[0])
        move_to([ee_pos[0], ee_pos[1], ee_pos[2] + 0.10], orn=quat_target, steps=220)

        now_z = p.getBasePositionAndOrientation(obj_id)[0][2]
        dz_lift = now_z - base_z
        if (dz_lift < -0.05) or (abs(dz_lift) > 0.5):
            print(f"[WARN] abnormal Δz on retry={dz_lift:.3f}, still fail.")
            lifted = False
        else:
            lifted = (dz_lift > LIFT_SUCCESS_DZ)
        print(f"[DEBUG] retry squeeze, Δz={dz_lift:.3f}, success={lifted}")

    # ---------- 松手 ----------
    for fid in finger_ids:
        p.setJointMotorControl2(panda_id, fid, p.POSITION_CONTROL, targetPosition=0.04, force=200)
    _step(int(0.20 * 480))

    return lifted

def load_obj_with_target_height(urdf_path: str, target_h: float, table_top_z: float, xy=(0.38, 0.0)):
    """按目标高度 target_h（米）自适应计算 globalScaling，任何 URDF 都能统一尺寸。"""
    # 先探测原始高度 h0
    probe_id = p.loadURDF(urdf_path, basePosition=[0,0,1.0], globalScaling=1.0)
    a0 = p.getAABB(probe_id, -1)
    h0 = max(1e-6, a0[1][2] - a0[0][2])
    p.removeBody(probe_id)

    sf = float(target_h) / h0
    base_z = table_top_z + 0.002 + 0.5 * float(target_h)
    obj_id = p.loadURDF(urdf_path,
                        basePosition=[xy[0], xy[1], base_z],
                        globalScaling=sf)
    return obj_id, sf, base_z, float(target_h)


# ------------------------------ Main ---------------------------

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--obj", type=str, default="cube.urdf")
    parser.add_argument("--grasps", type=str, default="grasp_6dof/dataset/sample_grasps.json")
    parser.add_argument("--out", type=str, default="grasp_6dof/dataset/validated_grasps_panda.json")
    parser.add_argument("--vis", type=int, default=1)
    parser.add_argument("--topk", type=int, default=12)
    parser.add_argument("--fast", action="store_true", help="关可视化/不sleep/缩短steps")
    parser.add_argument("--fast-scale", type=float, default=0.9, help="steps 缩放系数(0.6~0.95)")
    parser.add_argument("--cube-scale", type=float, default=0.08)
    parser.add_argument("--reset-each-trial", type=int, default=1)
    parser.add_argument("--seed", type=int, default=123)

    # IK/动力学可调参数
    parser.add_argument("--ee-index", type=int, default=11, help="8: hand, 11: gripper center")
    parser.add_argument("--ik-iters", type=int, default=400)
    parser.add_argument("--ik-attempts", type=int, default=5)
    parser.add_argument("--joint-force", type=float, default=900.0)
    parser.add_argument("--descent-step", type=float, default=0.002,
                        dest="descent_step", help="渐降步长(m)，默认 0.002")
    parser.add_argument("--descend-clear", type=float, default=0.020,
                        dest="descend_clear", help="从方块顶面上方多少米开始渐降，默认 0.020")
    parser.add_argument("--vel-close", type=float, default=0.25,
                        dest="vel_close", help="速度合爪阶段时长(s)，默认 0.25")
    parser.add_argument("--pos-close", type=float, default=1400,
                        dest="pos_close", help="位置夹紧的力(牛)，默认 900")
    parser.add_argument("--squeeze", type=float, default=0.80,
                        dest="squeeze", help="二次挤压时长(s)，默认 0.35")
    parser.add_argument("--summary-csv", type=str, default="grasp_6dof/out/summary.csv",
                    help="将本次实验的配置与结果附加写入该 CSV")


    args = parser.parse_args()
    set_global_seed(args.seed)
    
    def append_summary_row(path, fields, values):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        write_header = not os.path.exists(path)
        with open(path, "a", newline="") as f:
            w = csv.writer(f)
            if write_header:
                w.writerow(fields)
            w.writerow(values)
    
    # 连接仿真
    physicsClient = p.connect(p.GUI if (args.vis and not args.fast) else p.DIRECT)
    p.setAdditionalSearchPath(pybullet_data.getDataPath())
    p.setGravity(0, 0, -9.8)

    # —— 物理稳定性/确定性参数 ——
    p.setPhysicsEngineParameter(
        deterministicOverlappingPairs=1,
        collisionFilterMode=1,
        contactSlop=1e-3,
        enableConeFriction=1,
        solverResidualThreshold=1e-7,
        numSolverIterations=200,
        erp=0.2, contactERP=0.2, frictionERP=0.2,
        useSplitImpulse=1, splitImpulsePenetrationThreshold=-0.01
    )
    p.setTimeStep(1.0/480.0)
    save_env_snapshot()

    # 步进函数：fast 模式关闭 sleep 且按 scale 减少步数
    def step(n):
        steps = int(max(1, n * (args.fast_scale if args.fast else 1.0)))
        if args.fast or not args.vis:
            for _ in range(steps):
                p.stepSimulation()
        else:
            for _ in range(steps):
                p.stepSimulation()
                time.sleep(1/480.0)

    # 桌面
    table_id = p.loadURDF("table/table.urdf", basePosition=[0.5, 0, -0.63])
    TABLE_TOP_Z = get_table_top_z(table_id)
    print(f"[INFO] Detected table top z = {TABLE_TOP_Z:.3f}")

    p.changeDynamics(table_id, -1,
                     lateralFriction=1.6, rollingFriction=0.05, spinningFriction=0.02,
                     restitution=0.0)
    # 物体：静置在桌面
    CUBE_SCALE = float(args.cube_scale)
    CUBE_HALF_Z = 0.5 * CUBE_SCALE
    CUBE_XY = (0.38, 0.00)
    obj_z = TABLE_TOP_Z + CUBE_HALF_Z + 0.002
    obj_id, sf, obj_z, TARGET_H = load_obj_with_target_height(args.obj, args.cube_scale,    TABLE_TOP_Z, xy=CUBE_XY)
    print(f"[INFO] 对象放置：target_h={TARGET_H:.3f}m, auto_scale={sf:.3f}, z={obj_z:.3f}")

    p.changeDynamics(obj_id, -1,
        lateralFriction=3.0, rollingFriction=0.08, spinningFriction=0.15, restitution=0.0)
    print(f"[INFO] 方块已放在桌面上 (x={CUBE_XY[0]:.2f}, y={CUBE_XY[1]:.2f}, z={obj_z:.3f}, scale={CUBE_SCALE}).")
    
    init_obj_pos, init_obj_orn = p.getBasePositionAndOrientation(obj_id)

    # 先稳定
    step(int(0.5 * 480))

    # 读取 grasps；为空则兜底
    def set_gripper_width(width_m, speed=0.3, max_force=120):
        # Panda: finger joints usually 9 (left) & 10 (right)
        half = max(0.0, width_m * 0.5)
        p.setJointMotorControl2(panda_id, 9,  p.POSITION_CONTROL, targetPosition=half,
                                force=max_force, maxVelocity=speed)
        p.setJointMotorControl2(panda_id, 10, p.POSITION_CONTROL, targetPosition=half,
                                force=max_force, maxVelocity=speed)
        for _ in range(60):  # ~1s @60Hz
            p.stepSimulation()
            
    try:
        with open(args.grasps, "r") as f:
            grasps = json.load(f)
            if not isinstance(grasps, list):
                grasps = []
    except Exception:
        pass
    except Exception:
        grasps = []
    if args.topk is not None and len(grasps) > 0:
        if "score" in grasps[0]:
            grasps = sorted(grasps, key=lambda g: g.get("score", 0.0), reverse=True)
        grasps = grasps[:args.topk]

    if len(grasps) == 0:
        cx, cy, cz = p.getBasePositionAndOrientation(obj_id)[0]
        z_above = cz + 0.12
        yaw_list = np.linspace(-np.pi, np.pi, 12, endpoint=False)
        grasps = [{
            "position": [float(cx), float(cy), float(z_above)],
            "rpy": [float(np.pi), 0.0, float(yaw)]
        } for yaw in yaw_list]
        print(f"[WARN] No grasps in JSON. Generated {len(grasps)} top-down fallback grasps.")
    print(f"[INFO] Loaded {len(grasps)} grasps for validation.")

    # 当 --grasps 为空时用于 CSV tag 的占位名
    fallback = "auto_topdown" if len(grasps)>0 and "position" in grasps[0] and  grasps[0].get("rpy") else "auto_topdown"


    # 在加载 Panda 之后：
    panda_id = p.loadURDF("franka_panda/panda.urdf", basePosition=[0, 0, 0], useFixedBase=True)
    finger_ids = [9, 10]
    # 左右手指齿轮约束（对称相向运动）
    # 在 main() 里加载 panda_id 后，紧跟加：
    cid = p.createConstraint(
        parentBodyUniqueId=panda_id, parentLinkIndex=9,
        childBodyUniqueId=panda_id,  childLinkIndex=10,
        jointType=p.JOINT_GEAR, jointAxis=[1, 0, 0],
        parentFramePosition=[0, 0, 0], childFramePosition=[0, 0, 0]
    )
    p.changeConstraint(cid, gearRatio=-1, maxForce=200, erp=0.5)
    END_EFFECTOR_INDEX = int(args.ee_index)
    # 物体
    p.changeDynamics(obj_id, -1,
        lateralFriction=3.0, rollingFriction=0.08, spinningFriction=0.15, restitution=0.0)

    # 手指（加载后、每轮复位时都做一次）
    for fid in finger_ids:
        p.changeDynamics(panda_id, fid, lateralFriction=5.0, rollingFriction=0.12,  spinningFriction=0.10, contactStiffness=2500, contactDamping=80)



    # 统计
    validated, success_count = [], 0
    init_base_z = p.getBasePositionAndOrientation(obj_id)[0][2]

    for i, grasp in enumerate(grasps):
        # 每轮重置：臂+手指
        if args.reset_each_trial:
            for j in range(7):
                p.resetJointState(panda_id, j, 0.0)
            for fid in finger_ids:
                # 手指摩擦再提一档（避免小球打滑）
                p.changeDynamics(panda_id, fid,
            lateralFriction=5.0, rollingFriction=0.08, spinningFriction=0.10)
                p.resetJointState(panda_id, fid, 0.04)

            # ⭐ 复位方块到初始位姿（很关键）
            p.resetBasePositionAndOrientation(obj_id, init_obj_pos, init_obj_orn)
            step(int(0.15 * 480))  # 稍微稳定一下

        # ⭐ 每轮都重新读取“抬升成功”的基准高度
        init_base_z = p.getBasePositionAndOrientation(obj_id)[0][2]
        
        # --- 以 AABB 估算该物体在夹爪方向所需最小开口（+ 安全余量）---
        aabb = p.getAABB(obj_id, -1)
        dx = aabb[1][0] - aabb[0][0]
        dy = aabb[1][1] - aabb[0][1]
        need_open = float(max(dx, dy)) + 0.008  # 直径 + 6mm 余量
        suggest_open = float(grasp.get("width", 0.04)) + 0.004
        open_width_m = min(max(need_open, suggest_open), 0.080)


        
        ok = grasp_with_panda(
            obj_id, grasp, panda_id,
            end_effector_index=END_EFFECTOR_INDEX,
            finger_ids=finger_ids,
            table_top_z=TABLE_TOP_Z,
            init_base_z=init_base_z,
            open_width_m=open_width_m,           # ← 传进去
            descent_step=args.descent_step,
            descend_clear=args.descend_clear,
            vel_close=args.vel_close,
            pos_close=args.pos_close,
            squeeze=args.squeeze,
        )
        out_g = dict(grasp); out_g["success"] = bool(ok)
        # 附加观测字段
        cps_now = p.getContactPoints(bodyA=panda_id, bodyB=obj_id)
        out_g["contact_seen"] = any(c[3] in finger_ids for c in cps_now)
        now_z = p.getBasePositionAndOrientation(obj_id)[0][2]
        out_g["dz"] = round(float(now_z - init_base_z), 4)
        out_g["fell_off"] = bool((out_g["dz"] < -0.05) or (abs(out_g["dz"]) > 0.5))
        validated.append(out_g)
        if ok: success_count += 1
        print(f"[{i+1}/{len(grasps)}] Grasp success = {ok}")

    # 结果
    total = max(1, len(grasps))
    print(f"[INFO] Success rate = {success_count / total:.2f}")
    os.makedirs(os.path.dirname(args.out), exist_ok=True)
    with open(args.out, "w") as f:
        json.dump(validated, f, indent=2, ensure_ascii=False)
    print(f"[INFO] Saved validated grasps → {args.out}")

    # 物体形状标签（记录到 CSV）
    obj_aabb = p.getAABB(obj_id, -1)
    dx = obj_aabb[1][0] - obj_aabb[0][0]
    dy = obj_aabb[1][1] - obj_aabb[0][1]
    dz_ = obj_aabb[1][2] - obj_aabb[0][2]
    rx = abs(dx - dy) / max(1e-6, max(dx, dy))
    ry = abs(dx - dz_) / max(1e-6, max(dx, dz_))
    rz = abs(dy - dz_) / max(1e-6, max(dy, dz_))
    obj_shape = "sphere_like" if (rx < 0.15 and ry < 0.15 and rz < 0.15) else "other"

    fields = ["time","obj","cube_scale","topk","seed",
        "ee_index","ik_iters","ik_attempts","joint_force",
        "descent_step","descend_clear","vel_close","pos_close","squeeze",
        "fast","fast_scale",
        "n_trials","success_count","success_rate"
    ] + ["obj_shape","grasps_path","tag"]
    values = [
        datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        args.obj, args.cube_scale, args.topk, args.seed,
        args.ee_index, args.ik_iters, args.ik_attempts, args.joint_force,
        args.descent_step, args.descend_clear, args.vel_close, args.pos_close, args.squeeze,
        int(args.fast), args.fast_scale,
        len(grasps), success_count, round(success_count/max(1,len(grasps)), 4)
        ] + [obj_shape, args.grasps, f"{pathlib.Path(args.obj).name}_pc{int(args.pos_close)}_sq{args.squeeze}_topk{args.topk}_{pathlib.Path(args.grasps).stem if args.grasps else 'nograsps'}"]
    append_summary_row(args.summary_csv, fields, values)
    print(f"[INFO] Appended summary → {args.summary_csv}")

    if args.vis and not args.fast:
        input("Press Enter to exit simulation...")
    p.disconnect()

if __name__ == "__main__":
    main()
